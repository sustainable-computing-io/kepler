// SPDX-FileCopyrightText: 2025 The Kepler Authors
// SPDX-License-Identifier: Apache-2.0

package pod

import (
	"context"
	"net/http"

	"github.com/go-logr/logr"
	"github.com/stretchr/testify/mock"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/meta"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/record"
	"sigs.k8s.io/controller-runtime/pkg/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/config"
	"sigs.k8s.io/controller-runtime/pkg/healthz"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
)

func podWithStatus(
	containerStatus []corev1.ContainerStatus,
	ephemeralContainerStatus []corev1.ContainerStatus,
	initContainerStatus []corev1.ContainerStatus,
) *corev1.Pod {
	return &corev1.Pod{
		ObjectMeta: v1.ObjectMeta{
			Name:      "pod-name",
			UID:       "pod-uuid",
			Namespace: "pod-namespace",
		},
		Spec: corev1.PodSpec{},
		Status: corev1.PodStatus{
			ContainerStatuses:          containerStatus,
			EphemeralContainerStatuses: ephemeralContainerStatus,
			InitContainerStatuses:      initContainerStatus,
		},
	}
}

func cstatus(contIDs []string) []corev1.ContainerStatus {
	ret := make([]corev1.ContainerStatus, len(contIDs))
	for _, c := range contIDs {
		ret = append(ret, corev1.ContainerStatus{
			ContainerID: c,
		})
	}
	return ret
}

func mockGetConfig(kubeConfigPath string) (*rest.Config, error) {
	return &rest.Config{}, nil
}

var _ manager.Manager = &mockManager{}

// mockManager is an autogenerated mock type for the Manager type using mockery v2
type mockManager struct {
	mock.Mock
}

// Add provides a mock function with given fields: _a0
func (_m *mockManager) Add(_a0 manager.Runnable) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(manager.Runnable) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddHealthzCheck provides a mock function with given fields: name, check
func (_m *mockManager) AddHealthzCheck(name string, check healthz.Checker) error {
	ret := _m.Called(name, check)

	if len(ret) == 0 {
		panic("no return value specified for AddHealthzCheck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, healthz.Checker) error); ok {
		r0 = rf(name, check)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddMetricsServerExtraHandler provides a mock function with given fields: path, handler
func (_m *mockManager) AddMetricsServerExtraHandler(path string, handler http.Handler) error {
	ret := _m.Called(path, handler)

	if len(ret) == 0 {
		panic("no return value specified for AddMetricsServerExtraHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, http.Handler) error); ok {
		r0 = rf(path, handler)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddReadyzCheck provides a mock function with given fields: name, check
func (_m *mockManager) AddReadyzCheck(name string, check healthz.Checker) error {
	ret := _m.Called(name, check)

	if len(ret) == 0 {
		panic("no return value specified for AddReadyzCheck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, healthz.Checker) error); ok {
		r0 = rf(name, check)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Elected provides a mock function with no fields
func (_m *mockManager) Elected() <-chan struct{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Elected")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// GetAPIReader provides a mock function with no fields
func (_m *mockManager) GetAPIReader() client.Reader {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAPIReader")
	}

	var r0 client.Reader
	if rf, ok := ret.Get(0).(func() client.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.Reader)
		}
	}

	return r0
}

// GetCache provides a mock function with no fields
func (_m *mockManager) GetCache() cache.Cache {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCache")
	}

	var r0 cache.Cache
	if rf, ok := ret.Get(0).(func() cache.Cache); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Cache)
		}
	}

	return r0
}

// GetClient provides a mock function with no fields
func (_m *mockManager) GetClient() client.Client {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClient")
	}

	var r0 client.Client
	if rf, ok := ret.Get(0).(func() client.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.Client)
		}
	}

	return r0
}

// GetConfig provides a mock function with no fields
func (_m *mockManager) GetConfig() *rest.Config {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 *rest.Config
	if rf, ok := ret.Get(0).(func() *rest.Config); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rest.Config)
		}
	}

	return r0
}

// GetControllerOptions provides a mock function with no fields
func (_m *mockManager) GetControllerOptions() config.Controller {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetControllerOptions")
	}

	var r0 config.Controller
	if rf, ok := ret.Get(0).(func() config.Controller); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(config.Controller)
	}

	return r0
}

// GetEventRecorderFor provides a mock function with given fields: name
func (_m *mockManager) GetEventRecorderFor(name string) record.EventRecorder {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for GetEventRecorderFor")
	}

	var r0 record.EventRecorder
	if rf, ok := ret.Get(0).(func(string) record.EventRecorder); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(record.EventRecorder)
		}
	}

	return r0
}

// GetFieldIndexer provides a mock function with no fields
func (_m *mockManager) GetFieldIndexer() client.FieldIndexer {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFieldIndexer")
	}

	var r0 client.FieldIndexer
	if rf, ok := ret.Get(0).(func() client.FieldIndexer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.FieldIndexer)
		}
	}

	return r0
}

// GetHTTPClient provides a mock function with no fields
func (_m *mockManager) GetHTTPClient() *http.Client {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetHTTPClient")
	}

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func() *http.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	return r0
}

// GetLogger provides a mock function with no fields
func (_m *mockManager) GetLogger() logr.Logger {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLogger")
	}

	var r0 logr.Logger
	if rf, ok := ret.Get(0).(func() logr.Logger); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(logr.Logger)
	}

	return r0
}

// GetRESTMapper provides a mock function with no fields
func (_m *mockManager) GetRESTMapper() meta.RESTMapper {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRESTMapper")
	}

	var r0 meta.RESTMapper
	if rf, ok := ret.Get(0).(func() meta.RESTMapper); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meta.RESTMapper)
		}
	}

	return r0
}

// GetScheme provides a mock function with no fields
func (_m *mockManager) GetScheme() *runtime.Scheme {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetScheme")
	}

	var r0 *runtime.Scheme
	if rf, ok := ret.Get(0).(func() *runtime.Scheme); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.Scheme)
		}
	}

	return r0
}

// GetWebhookServer provides a mock function with no fields
func (_m *mockManager) GetWebhookServer() webhook.Server {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWebhookServer")
	}

	var r0 webhook.Server
	if rf, ok := ret.Get(0).(func() webhook.Server); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(webhook.Server)
		}
	}

	return r0
}

// Start provides a mock function with given fields: ctx
func (_m *mockManager) Start(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockCache is an autogenerated mock type for the Cache type
type mockCache struct {
	mock.Mock
}

// Get provides a mock function with given fields: ctx, key, obj, opts
func (_m *mockCache) Get(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error); ok {
		r0 = rf(ctx, key, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetInformer provides a mock function with given fields: ctx, obj, opts
func (_m *mockCache) GetInformer(ctx context.Context, obj client.Object, opts ...cache.InformerGetOption) (cache.Informer, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInformer")
	}

	var r0 cache.Informer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...cache.InformerGetOption) (cache.Informer, error)); ok {
		return rf(ctx, obj, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...cache.InformerGetOption) cache.Informer); ok {
		r0 = rf(ctx, obj, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Informer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, client.Object, ...cache.InformerGetOption) error); ok {
		r1 = rf(ctx, obj, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInformerForKind provides a mock function with given fields: ctx, gvk, opts
func (_m *mockCache) GetInformerForKind(ctx context.Context, gvk schema.GroupVersionKind, opts ...cache.InformerGetOption) (cache.Informer, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, gvk)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInformerForKind")
	}

	var r0 cache.Informer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionKind, ...cache.InformerGetOption) (cache.Informer, error)); ok {
		return rf(ctx, gvk, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionKind, ...cache.InformerGetOption) cache.Informer); ok {
		r0 = rf(ctx, gvk, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Informer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.GroupVersionKind, ...cache.InformerGetOption) error); ok {
		r1 = rf(ctx, gvk, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IndexField provides a mock function with given fields: ctx, obj, field, extractValue
func (_m *mockCache) IndexField(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc) error {
	ret := _m.Called(ctx, obj, field, extractValue)

	if len(ret) == 0 {
		panic("no return value specified for IndexField")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, string, client.IndexerFunc) error); ok {
		r0 = rf(ctx, obj, field, extractValue)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: ctx, list, opts
func (_m *mockCache) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, list)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.ObjectList, ...client.ListOption) error); ok {
		r0 = rf(ctx, list, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveInformer provides a mock function with given fields: ctx, obj
func (_m *mockCache) RemoveInformer(ctx context.Context, obj client.Object) error {
	ret := _m.Called(ctx, obj)

	if len(ret) == 0 {
		panic("no return value specified for RemoveInformer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object) error); ok {
		r0 = rf(ctx, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields: ctx
func (_m *mockCache) Start(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitForCacheSync provides a mock function with given fields: ctx
func (_m *mockCache) WaitForCacheSync(ctx context.Context) bool {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitForCacheSync")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

type fakeManager struct {
	client client.Client
	scheme *runtime.Scheme
	ctx    context.Context
}

func (f *fakeManager) Start(ctx context.Context) error {
	f.ctx = ctx
	<-ctx.Done()
	return nil
}

func (f *fakeManager) GetCache() cache.Cache {
	return &fakeCache{client: f.client}
}

func (f *fakeManager) GetClient() client.Client                                { return f.client }
func (f *fakeManager) GetScheme() *runtime.Scheme                              { return f.scheme }
func (f *fakeManager) Add(manager.Runnable) error                              { return nil }
func (f *fakeManager) AddHealthzCheck(string, healthz.Checker) error           { return nil }
func (f *fakeManager) AddReadyzCheck(string, healthz.Checker) error            { return nil }
func (f *fakeManager) AddMetricsServerExtraHandler(string, http.Handler) error { return nil }
func (f *fakeManager) Elected() <-chan struct{}                                { return nil }
func (f *fakeManager) GetAPIReader() client.Reader                             { return f.client }
func (f *fakeManager) GetConfig() *rest.Config                                 { return &rest.Config{} }
func (f *fakeManager) GetControllerOptions() config.Controller                 { return config.Controller{} }
func (f *fakeManager) GetEventRecorderFor(string) record.EventRecorder         { return nil }
func (f *fakeManager) GetFieldIndexer() client.FieldIndexer                    { return &fakeIndexer{f.client} }
func (f *fakeManager) GetHTTPClient() *http.Client                             { return nil }
func (f *fakeManager) GetLogger() logr.Logger                                  { return logr.Discard() }
func (f *fakeManager) GetRESTMapper() meta.RESTMapper                          { return nil }
func (f *fakeManager) GetWebhookServer() webhook.Server                        { return nil }

type fakeCache struct {
	client client.Client
}

func (f *fakeCache) Get(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) error {
	return f.client.Get(ctx, key, obj, opts...)
}

func (f *fakeCache) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error {
	return f.client.List(ctx, list, opts...)
}

func (f *fakeCache) GetInformer(context.Context, client.Object, ...cache.InformerGetOption) (cache.Informer, error) {
	return nil, nil
}

func (f *fakeCache) GetInformerForKind(context.Context, schema.GroupVersionKind, ...cache.InformerGetOption) (cache.Informer, error) {
	return nil, nil
}

func (f *fakeCache) Start(context.Context) error           { return nil }
func (f *fakeCache) WaitForCacheSync(context.Context) bool { return true }
func (f *fakeCache) IndexField(context.Context, client.Object, string, client.IndexerFunc) error {
	return nil
}
func (f *fakeCache) RemoveInformer(context.Context, client.Object) error { return nil }

type fakeIndexer struct {
	client client.Client
}

func (f *fakeIndexer) IndexField(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc) error {
	return nil
}
